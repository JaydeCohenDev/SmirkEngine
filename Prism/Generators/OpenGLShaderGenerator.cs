using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Prism.Analyzer;
using Prism.Attributes;
using Prism.Compiler;
using Prism.Core;
using Prism.Types;

namespace Prism.Generators;

public class OpenGLShaderGenerator : ShaderCodeGeneratorBase
{
    public class OpenGLShaderTypeMap : ShaderTypeMap
    {
        public override string MapVec2() => "vec2";
        public override string MapVec3() => "vec3";
        public override string MapVec4() => "vec4";
        public override string MapFloat() => "float";
        public override string MapMat3() => "mat3";
        public override string MapMat4() => "mat4";
    }

    public class OpenGLShaderExpressionVisitor : ShaderExpressionVisitor
    {
        protected virtual string ConvertFunctionCall(string methodName, string arguments)
        {
            return $"{methodName}({arguments})";
        }

        protected virtual string ConvertOperator(SyntaxToken operatorToken)
        {
            return operatorToken.Kind() switch
            {
                SyntaxKind.PlusToken => "+",
                SyntaxKind.MinusToken => "-",
                SyntaxKind.AsteriskToken => "*",
                SyntaxKind.SlashToken => "/",
                SyntaxKind.PlusEqualsToken => "+=",
                SyntaxKind.MinusEqualsToken => "-=",
                SyntaxKind.AsteriskEqualsToken => "*=",
                SyntaxKind.SlashEqualsToken => "/=",
                SyntaxKind.EqualsToken => "=",
                _ => operatorToken.ToString()
            };
        }

        public override string? VisitBinaryExpression(BinaryExpressionSyntax node)
        {
            bool needsParentheses = false;//node.Left is BinaryExpressionSyntax || node.Right is BinaryExpressionSyntax;
            
            string left = Visit(node.Left);
            string right = Visit(node.Right);
            string op = ConvertOperator(node.OperatorToken);
            
            return needsParentheses ? $"({left} {op} {right})" : $"{left} {op} {right}";
        }

        public override string? VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
        {
            return $"({Visit(node.Expression)})";
        }

        public override string? VisitLiteralExpression(LiteralExpressionSyntax node)
        {
            return node.ToString();
        }

        public override string? VisitIdentifierName(IdentifierNameSyntax node)
        {
            return node.Identifier.Text;
        }

        public override string? VisitInvocationExpression(InvocationExpressionSyntax node)
        {
            string methodName = ((IdentifierNameSyntax)node.Expression).Identifier.Text;
            string arguments = string.Join(", ", node.ArgumentList.Arguments.Select(a => Visit(a.Expression)));
            return ConvertFunctionCall(methodName, arguments);
        }

        public override string? VisitAssignmentExpression(AssignmentExpressionSyntax node)
        {
            string left = Visit(node.Left);
            string right = Visit(node.Right);
            string op = ConvertOperator(node.OperatorToken);
            return $"{left} {op} {right}";
        }
    }

    public class BlankExpressionVisitor : ShaderExpressionVisitor
    {
        public override string? Visit(SyntaxNode? node)
        {
            if(node == null) return string.Empty;

            var result = new StringBuilder();

            // Traverse all child nodes and tokens in the correct order
            foreach (var item in node.ChildNodesAndTokens())
            {
                if (item.IsNode)
                {
                    // Recursively process child nodes
                    result.Append(Visit(item.AsNode()));
                }
                else if (item.IsToken)
                {
                    
                    // Include leading trivia (e.g., spaces, comments, newlines)
                    result.Append(item.AsToken().LeadingTrivia.ToFullString());

                    // Append the token itself
                    result.Append(item.AsToken().ToString());

                    // Include trailing trivia
                    result.Append(item.AsToken().TrailingTrivia.ToFullString());
                }
            }

            return result.ToString();
        }
        
        

    }
    
    private OpenGLShaderTypeMap _typeMap;
    private ShaderExpressionVisitor _expressionVisitor;

    public OpenGLShaderGenerator()
    {
        _typeMap = new OpenGLShaderTypeMap();
        _expressionVisitor = new BlankExpressionVisitor();
    }
    
    public override string GenerateShaderCode(Type shaderType, ShaderVariables variables)
    {
        var code = new StringBuilder();
        code.AppendLine($"//Generated by Prism [{shaderType.FullName}]");
        code.AppendLine("#version 450\n");
        
        AppendVariableDeclarations(code, variables);

        ClassDeclarationSyntax shaderClassSyntaxTree = null;
        try
        {
            shaderClassSyntaxTree = ShaderAnalyzer.AnalyzeShader(shaderType);
        }
        catch (Exception e)
        {
            throw new Exception($"Error analyzing shader {shaderType.FullName}", e);
        }
        
        var methods = shaderType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance |
                                            BindingFlags.DeclaredOnly);
        var entry = methods.FirstOrDefault(m => m.GetCustomAttribute<ShaderEntry>() != null);

        foreach (var method in methods)
        {
            var methodBody = shaderClassSyntaxTree.DescendantNodes().OfType<MethodDeclarationSyntax>()
                .First(m => m.Identifier.ValueText == method.Name);
            AppendFunction(code, method, methodBody);
        }
        
        return code.ToString();
    }

    protected override ShaderTypeMap GetTypeMap()
    {
        return _typeMap;
    }

    protected override void AppendVariableDeclarations(StringBuilder shaderCode, ShaderVariables variables)
    {
        var inputs = variables.Inputs;
        if (inputs.Count >= 0)
        {
            shaderCode.AppendLine("//Inputs");
            foreach (var variable in inputs)
            {
                var typeName = MapType(variable.Type);
                shaderCode.AppendLine($"layout(binding = {variable.Binding}) uniform {typeName} {variable.Name};");
            }
            shaderCode.AppendLine();
        }
        
        var outputs = variables.Outputs;
        if (outputs.Count > 0)
        {
            shaderCode.AppendLine("//Outputs");
            foreach (var variable in outputs)
            {
                var typeName = MapType(variable.Type);
                shaderCode.AppendLine($"layout(location = {variable.Location}) out {typeName} {variable.Name};");
            }
            shaderCode.AppendLine();
        }
    }

    protected override void AppendFunctionHeader(StringBuilder shaderCode, MethodInfo methodInfo)
    {
        shaderCode.Append($"{MapType(methodInfo.ReturnType)} {methodInfo.Name}(");
        shaderCode.AppendJoin(", ", methodInfo.GetParameters().Select(p => $"{MapType(p.ParameterType)} {p.Name}"));
        shaderCode.AppendLine(")");
    }

    protected override void AppendFunctionBody(StringBuilder shaderCode, MethodDeclarationSyntax methodBody)
    {
        var visitedBody = _expressionVisitor.Visit(methodBody.Body);
        var normalizedBody = NormalizeIndentation(visitedBody);
        shaderCode.AppendLine(normalizedBody);
    }
    
    private string NormalizeIndentation(string code)
    {
        // Split the code into lines
        var lines = code.Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries);

        // Find the minimum indentation (ignoring empty lines)
        var minIndent = lines
            .Where(line => !string.IsNullOrWhiteSpace(line)) // Ignore blank lines
            .Select(line => line.TakeWhile(char.IsWhiteSpace).Count()) // Count leading spaces
            .DefaultIfEmpty(0) // Default to 0 if no lines are found
            .Min();

        // Trim the base indentation from each line
        return string.Join(Environment.NewLine, lines.Select(line =>
            line.Length >= minIndent ? line[minIndent..] : line.TrimStart()));
    }


    private string HandleStatement(StatementSyntax statement)
    {
        return statement switch
        {
            ExpressionStatementSyntax exprStatement => _expressionVisitor.Visit(exprStatement.Expression) + ";",
            ReturnStatementSyntax returnStatement => $"return {_expressionVisitor.Visit(returnStatement.Expression)};",
            IfStatementSyntax ifStatement => HandleIfStatement(ifStatement),
            ForStatementSyntax forStatement => HandleForStatement(forStatement),
            WhileStatementSyntax whileStatement => HandleWhileStatement(whileStatement),
            _ => statement.ToString()
        };
    }

    private string HandleIfStatement(IfStatementSyntax ifStatement)
    {
        string condition = _expressionVisitor.Visit(ifStatement.Condition);
        string thenBlock = HandleStatement(ifStatement.Statement);
        string elseBlock = ifStatement.Else != null ? $" else {{ {HandleStatement(ifStatement.Else.Statement)} }}" : "";
        return $"if ({condition}) {{ {thenBlock} }}{elseBlock}";
    }
    
    private string HandleForStatement(ForStatementSyntax forStatement)
    {
        string declaration = _expressionVisitor.Visit(forStatement.Declaration);
        string condition = _expressionVisitor.Visit(forStatement.Condition);
        string increment = _expressionVisitor.Visit(forStatement.Incrementors.First());
        string body = HandleStatement(forStatement.Statement);
        return $"for ({declaration}; {condition}; {increment}) {{ {body} }}";
    }
    
    private string HandleWhileStatement(WhileStatementSyntax whileStatement)
    {
        string condition = _expressionVisitor.Visit(whileStatement.Condition);
        string body = HandleStatement(whileStatement.Statement);
        return $"while ({condition}) {{ {body} }}";
    }
}