using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Prism.Analyzer;
using Prism.Attributes;
using Prism.Compiler;
using Prism.Core;
using Prism.Types;

namespace Prism.Generators;

public class OpenGLShaderGenerator : ShaderCodeGeneratorBase
{
    public class OpenGLShaderTypeMap : ShaderTypeMap
    {
        public override string MapVec2() => "vec2";
        public override string MapVec3() => "vec3";
        public override string MapVec4() => "vec4";
        public override string MapFloat() => "float";
        public override string MapMat3() => "mat3";
        public override string MapMat4() => "mat4";
    }

    public class OpenGLShaderExpressionVisitor : ShaderExpressionVisitor
    {
        public override string? Visit(SyntaxNode? node)
        {
            if(node == null) return string.Empty;

            var result = new StringBuilder();

            // Traverse all child nodes and tokens in the correct order
            foreach (var item in node.ChildNodesAndTokens())
            {
                if (item.IsNode)
                {
                    // Recursively process child nodes
                    result.Append(item.AsNode() switch
                    {
                        IdentifierNameSyntax identifierNameSyntax => VisitIdentifierName(identifierNameSyntax),
                        _ => Visit(item.AsNode())
                    });
                    
                }
                else if (item.IsToken)
                {
                    
                    // Include leading trivia (e.g., spaces, comments, newlines)
                    result.Append(item.AsToken().LeadingTrivia.ToFullString());

                    // Append the token itself
                    result.Append(item.AsToken().ToString());

                    // Include trailing trivia
                    result.Append(item.AsToken().TrailingTrivia.ToFullString());
                }
            }

            return result.ToString();
        }


        public override string? VisitIdentifierName(IdentifierNameSyntax node)
        {
            // Replace the content while maintaining leading/trailing trivia
            var newText = node.Identifier.Text switch
            {
                "Vec2" => "vec2",
                "Vec3" => "vec3",
                "Vec4" => "vec4",
                "Mat3" => "mat3",
                "Mat4" => "mat4",
                "VertexPosition" => "gl_Position",
                _ => node.Identifier.Text
            };

            // Apply the formatting (leading and trailing trivia) back to the modified text
            var replacedNode = node.WithIdentifier(SyntaxFactory.Identifier(newText))
                .WithLeadingTrivia(node.GetLeadingTrivia())
                .WithTrailingTrivia(node.GetTrailingTrivia());

            // Return the final result as a string
            return replacedNode.ToFullString();
        }
    }
    
    private OpenGLShaderTypeMap _typeMap;
    private ShaderExpressionVisitor _expressionVisitor;

    public OpenGLShaderGenerator()
    {
        _typeMap = new OpenGLShaderTypeMap();
        _expressionVisitor = new OpenGLShaderExpressionVisitor();
    }
    
    public override string GenerateShaderCode(Type shaderType, ShaderVariables variables)
    {
        var code = new StringBuilder();
        code.AppendLine($"//Generated by Prism [{shaderType.FullName}]");
        code.AppendLine("#version 450\n");
        
        AppendVariableDeclarations(code, variables);

        ClassDeclarationSyntax shaderClassSyntaxTree = null;
        try
        {
            shaderClassSyntaxTree = ShaderAnalyzer.AnalyzeShader(shaderType);
        }
        catch (Exception e)
        {
            throw new Exception($"Error analyzing shader {shaderType.FullName}", e);
        }
        
        var methods = shaderType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance |
                                            BindingFlags.DeclaredOnly);

        foreach (var method in methods)
        {
            var methodBody = shaderClassSyntaxTree.DescendantNodes().OfType<MethodDeclarationSyntax>()
                .First(m => m.Identifier.ValueText == method.Name);
            AppendFunction(code, method, methodBody);
        }
        
        return code.ToString();
    }

    protected override ShaderTypeMap GetTypeMap()
    {
        return _typeMap;
    }

    protected override void AppendVariableDeclarations(StringBuilder shaderCode, ShaderVariables variables)
    {
        var inputs = variables.Inputs;
        if (inputs.Count >= 0)
        {
            foreach (var variable in inputs)
            {
                var typeName = MapType(variable.Type);
                shaderCode.AppendLine($"layout(location = {variable.Binding}) {typeName} {variable.Name};");
            }
            shaderCode.AppendLine();
        }
        
        var outputs = variables.Outputs;
        if (outputs.Count > 0)
        {
            foreach (var variable in outputs)
            {
                var typeName = MapType(variable.Type);
                shaderCode.AppendLine($"out {typeName} {variable.Name};");
            }
            shaderCode.AppendLine();
        }
    }

    protected override void AppendFunctionHeader(StringBuilder shaderCode, MethodInfo methodInfo)
    {
        shaderCode.Append($"{MapType(methodInfo.ReturnType)} {methodInfo.Name}(");
        shaderCode.AppendJoin(", ", methodInfo.GetParameters().Select(p => $"{MapType(p.ParameterType)} {p.Name}"));
        shaderCode.AppendLine(")");
    }

    protected override void AppendFunctionBody(StringBuilder shaderCode, MethodDeclarationSyntax methodBody)
    {
        var visitedBody = _expressionVisitor.Visit(methodBody.Body);
        var normalizedBody = NormalizeIndentation(visitedBody);
        shaderCode.AppendLine(normalizedBody);
    }
    
    private string NormalizeIndentation(string code)
    {
        // Split the code into lines
        var lines = code.Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries);

        // Find the minimum indentation (ignoring empty lines)
        var minIndent = lines
            .Where(line => !string.IsNullOrWhiteSpace(line)) // Ignore blank lines
            .Select(line => line.TakeWhile(char.IsWhiteSpace).Count()) // Count leading spaces
            .DefaultIfEmpty(0) // Default to 0 if no lines are found
            .Min();

        // Trim the base indentation from each line
        return string.Join(Environment.NewLine, lines.Select(line =>
            line.Length >= minIndent ? line[minIndent..] : line.TrimStart()));
    }
}