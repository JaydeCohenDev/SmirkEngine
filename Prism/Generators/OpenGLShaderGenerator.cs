using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Prism.Analyzer;
using Prism.Attributes;
using Prism.Compiler;
using Prism.Core;
using Prism.Types;

namespace Prism.Generators;

public class OpenGLShaderGenerator : ShaderCodeGeneratorBase
{
    public class OpenGLShaderTypeMap : ShaderTypeMap
    {
        public override string MapVec2() => "vec2";
        public override string MapVec3() => "vec3";
        public override string MapVec4() => "vec4";
        public override string MapFloat() => "float";
        public override string MapMat3() => "mat3";
        public override string MapMat4() => "mat4";
    }

    public class OpenGLShaderExpressionVisitor : ShaderExpressionVisitor
    {
        
    }
    
    private OpenGLShaderTypeMap _typeMap;
    private ShaderExpressionVisitor _expressionVisitor;

    public OpenGLShaderGenerator()
    {
        _typeMap = new OpenGLShaderTypeMap();
        _expressionVisitor = new OpenGLShaderExpressionVisitor();
    }
    
    public override string GenerateShaderCode(Type shaderType, ShaderVariables variables)
    {
        var code = new StringBuilder();
        code.AppendLine($"//Generated by Prism [{shaderType.FullName}]");
        code.AppendLine("#version 450\n");
        
        AppendVariableDeclarations(code, variables);

        ClassDeclarationSyntax shaderClassSyntaxTree = null;
        try
        {
            shaderClassSyntaxTree = ShaderAnalyzer.AnalyzeShader(shaderType);
        }
        catch (Exception e)
        {
            throw new Exception($"Error analyzing shader {shaderType.FullName}", e);
        }
        
        var methods = shaderType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance |
                                            BindingFlags.DeclaredOnly);
        var entry = methods.FirstOrDefault(m => m.GetCustomAttribute<ShaderEntry>() != null);

        foreach (var method in methods)
        {
            var methodBody = shaderClassSyntaxTree.DescendantNodes().OfType<MethodDeclarationSyntax>()
                .First(m => m.Identifier.ValueText == method.Name);
            AppendFunction(code, method, methodBody);
        }
        
        return code.ToString();
    }

    protected override ShaderTypeMap GetTypeMap()
    {
        return _typeMap;
    }

    protected override void AppendVariableDeclarations(StringBuilder shaderCode, ShaderVariables variables)
    {
        var inputs = variables.Inputs;
        if (inputs.Count >= 0)
        {
            shaderCode.AppendLine("//Inputs");
            foreach (var variable in inputs)
            {
                var typeName = MapType(variable.Type);
                shaderCode.AppendLine($"layout(binding = {variable.Binding}) uniform {typeName} {variable.Name};");
            }
            shaderCode.AppendLine();
        }
        
        var outputs = variables.Outputs;
        if (outputs.Count >= 0)
        {
            shaderCode.AppendLine("//Outputs");
            foreach (var variable in outputs)
            {
                var typeName = MapType(variable.Type);
                shaderCode.AppendLine($"layout(location = {variable.Location}) out {typeName} {variable.Name};");
            }
            shaderCode.AppendLine();
        }
    }

    protected override void AppendFunctionHeader(StringBuilder shaderCode, MethodInfo methodInfo)
    {
        shaderCode.Append($"{MapType(methodInfo.ReturnType)} {methodInfo.Name}(");
        shaderCode.AppendJoin(", ", methodInfo.GetParameters().Select(p => $"{MapType(p.ParameterType)} {p.Name}"));
        shaderCode.AppendLine(")");
    }

    protected override void AppendFunctionBody(StringBuilder shaderCode, MethodDeclarationSyntax methodBody)
    {
        shaderCode.AppendLine("{");

        foreach (var statement in methodBody.Body.Statements)
        {
            shaderCode.AppendLine(HandleStatement(statement));
        }
        
        shaderCode.AppendLine("}");
    }

    private string HandleStatement(StatementSyntax statement)
    {
        return statement switch
        {
            ExpressionStatementSyntax exprStatement => _expressionVisitor.Visit(exprStatement.Expression),
            ReturnStatementSyntax returnStatement => $"return {_expressionVisitor.Visit(returnStatement.Expression)}",
            IfStatementSyntax ifStatement => HandleIfStatement(ifStatement),
            ForStatementSyntax forStatement => HandleForStatement(forStatement),
            WhileStatementSyntax whileStatement => HandleWhileStatement(whileStatement),
            _ => statement.ToString()
        };
    }

    private string HandleIfStatement(IfStatementSyntax ifStatement)
    {
        string condition = _expressionVisitor.Visit(ifStatement.Condition);
        string thenBlock = HandleStatement(ifStatement.Statement);
        string elseBlock = ifStatement.Else != null ? $" else {{ {HandleStatement(ifStatement.Else.Statement)} }}" : "";
        return $"if ({condition}) {{ {thenBlock} }}{elseBlock}";
    }
    
    private string HandleForStatement(ForStatementSyntax forStatement)
    {
        string declaration = _expressionVisitor.Visit(forStatement.Declaration);
        string condition = _expressionVisitor.Visit(forStatement.Condition);
        string increment = _expressionVisitor.Visit(forStatement.Incrementors.First());
        string body = HandleStatement(forStatement.Statement);
        return $"for ({declaration}; {condition}; {increment}) {{ {body} }}";
    }
    
    private string HandleWhileStatement(WhileStatementSyntax whileStatement)
    {
        string condition = _expressionVisitor.Visit(whileStatement.Condition);
        string body = HandleStatement(whileStatement.Statement);
        return $"while ({condition}) {{ {body} }}";
    }
}